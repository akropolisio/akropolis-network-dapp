import { bind } from 'decko';
import React, { createRef } from 'react';
import { IFrontendAragonApp } from '@aragon/types';

import { Preloader } from 'shared/view/elements';
import { StylesProps, provideStyles } from './AppIFrame.style';

// See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe for details about sandbox
// `sandbox` works like a whitelist: by default, almost every functionality is restricted.
const SANDBOX = [
  // Allows new browsing contexts to be created (window.open, target="_blank").
  'allow-popups',

  // Allows new browsing contexts (e.g. new windows or tabs) generated by the
  // iframe to escape the sandbox restrictions. Otherwise, new contexts would
  // share the same restrictions as their originating iframe (in our case, the
  // new contexts would only have the ability to run JavaScript).
  'allow-popups-to-escape-sandbox',

  // Gotta run 'em all!
  'allow-scripts',

  // Allow forms to be submitted
  'allow-forms',

  // Note that we haven't enabled:
  //   - 'allow-same-origin':
  //       The most important security setting: leaving this disabled lets the
  //       iframe be considered as coming from a unique, orphan origin. This
  //       means that the page won't have access to any cookies, local/session
  //       storage, or access to open pages (e.g. the parent window, this Dapp).
  //
  //       However, this does force some restrictions:
  //         - `window.postMessage()` must use `*` as an origin to communicate
  //           with this iframe
  //         - React devtools can't be hooked in from the browser, so you have
  //           to use the native `react-devtools` electron app for debugging
  //
  //  - 'allow-top-navigation':
  //       Leaving this disabled disallows the iframe from navigating the
  //       Dapp's context (e.g. to a malicious page)
].join(' ');

interface IOwnProps {
  app: IFrontendAragonApp;
  onLoad(iframe: HTMLIFrameElement): void;
  onMessage?(event: MessageEvent): void;
}

interface IState {
  hidePreloader: boolean;
}

type IProps = IOwnProps & StylesProps;

class AppIFrame extends React.Component<IProps, IState> {
  public state: IState = {
    hidePreloader: true,
  };
  private iframe = createRef<HTMLIFrameElement>();

  public componentDidMount() {
    window.addEventListener('message', this.handleReceiveMessage, false);
    this.navigateIFrame(this.props.app.src);
  }

  public componentWillReceiveProps(nextProps: IProps) {
    const { app: nextApp } = nextProps;
    if (
      nextApp.src !== this.props.app.src ||
      // Also navigate when it's the same app, but a different instance
      nextApp.proxyAddress !== this.props.app.proxyAddress
    ) {
      this.navigateIFrame(nextApp.src);
    }
  }

  public componentWillUnmount() {
    window.removeEventListener('message', this.handleReceiveMessage, false);
  }

  @bind
  public sendMessage(data: any) {
    // Must use '*' for origin as we've sandboxed the iframe's origin
    this.iframe.current &&
      this.iframe.current.contentWindow &&
      this.iframe.current.contentWindow.postMessage(data, '*');
  }

  public render() {
    const { app, classes } = this.props;
    const { hidePreloader } = this.state;

    const isAllowedApp = Boolean(app.src);
    if (!isAllowedApp) { return null; }

    return (
      <div className={classes.root}>
        {!hidePreloader && (
          <div className={classes.preloader}><Preloader /></div>
        )}
        <iframe
          className={classes.iframe}
          name="AppIFrame"
          allow="camera *; microphone *"
          frameBorder="0"
          onLoad={this.handleOnLoad}
          ref={this.iframe}
          sandbox={SANDBOX}
        />
      </div>
    );
  }

  private navigateIFrame(src: string) {
    // Rather than load src=undefined, this component hides itself. That way,
    // if the user later navigates back to the same src, we don't have to
    // reload the iframe.
    if (!src || !this.iframe.current || !this.iframe.current.parentNode) { return; }

    this.setState({ hidePreloader: false });

    // Detach the iframe from the DOM before setting the src to avoid adding
    // history state
    const containerNode = this.iframe.current.parentNode;
    this.iframe.current.remove();
    this.iframe.current.src = src;
    containerNode.append(this.iframe.current);
  }

  @bind
  private handleOnLoad() {
    this.setState({ hidePreloader: true });
    this.iframe.current && this.props.onLoad(this.iframe.current);
  }

  @bind
  private handleReceiveMessage(event: MessageEvent) {
    const { onMessage } = this.props;
    if (
      // Make sure the event actually came from the iframe window
      // We can't use event.origin as it's always null due to the origin sandboxing
      this.iframe.current && event.source === this.iframe.current.contentWindow
    ) {
      onMessage && onMessage(event);
    }
  }
}

export { AppIFrame as AppIFrameComponent };
export default provideStyles(AppIFrame);
